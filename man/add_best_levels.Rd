% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_best_levels.R
\name{add_best_levels}
\alias{add_best_levels}
\alias{get_best_levels}
\title{Add a good subset of features from high-cardinality variables in a
multiple-row-per-observation table}
\usage{
add_best_levels(d, longsheet, id, groups, outcome, n_levels = 100,
  positive_class = "Y", levels = NULL, fill, fun = sum,
  missing_fill = NA)

get_best_levels(d, longsheet, id, groups, outcome, n_levels = 100,
  positive_class = "Y")
}
\arguments{
\item{d}{Data frame to use in models, at desired grain. Has id and outcome}

\item{longsheet}{Data frame containing multiple observations per grain. Has
id and groups}

\item{id}{Name of identifier column, unquoted. Must be present and identical
in both tables}

\item{groups}{Name of grouping column, unquoted}

\item{outcome}{Name of outcome column, unquoted}

\item{n_levels}{Number of levels to return, default = 100. An attempt is made
to return half levels positively associated with the outcome and half
negatively. If n_levels is greater than the number present, all levels will
be returned}

\item{positive_class}{If classification model, the positive class of the
outcome, default = "Y"; ignored if regression}

\item{levels}{Character vector of levels to pivot and add. This is a
convenience for when add_best_levels was used in training and the same
columns are desired for deployment.}

\item{fill}{Passed to \code{\link{pivot}}. Column to be used to fill the
values of cells in the output, perhaps after aggregation by \code{fun}. If
\code{fill} is not provided, counts will be used, as though a fill column
of 1s had been provided.}

\item{fun}{Passed to \code{\link{pivot}}. Function for aggregation, defaults
to \code{sum}. Custom functions can be used with the same syntax as the
apply family of functions, e.g. \code{fun = function(x)
some_function(another_fun(x))}.}

\item{missing_fill}{Passed to \code{\link{pivot}}. Value to fill for
combinations of grain and spread that are not present. Defaults to NA, but
0 may be useful as well.}
}
\value{
For \code{add_best_levels}, d with new columns for the best levels
  added and an attribute containing the names of levels added. For
  \code{get_best_levels}, a character vector of the best levels.
}
\description{
In healthcare, we are often faced with very-high cardinality
  categorical variables, where using all of the categories results in very
  long model training times and high signal-to-noise. These functions help
  identify a subset of categories that are likely to be valuable features.

  \code{get_best_levels} finds levels of \code{groups} that are likely to be
  useful predictors in \code{d} and returns them as a character vector.
  \code{add_best_levels} does the same and adds them, pivoted, to \code{d}.
  The function attempts to find both positive and negative predictors of
  \code{outcome}.

  \code{add_best_levels} stores the best levels in an attribute of the
  returned data frame called \code{paste0(groups, "_levels")}, i.e. the name
  of the groups column followed by underscore-levels. This is useful in
  deployment, to ensure all columns created in training are again created
  (see final example).

  \code{add_best_levels} accepts arguments that are passed to
  \code{\link{pivot}}; however, note that these are not used in determining
  the best levels. I.e. \code{get_best_levels} determines which levels are
  likely to be good predictors looking only at the distribution of outcome
  values for observations where the levels are present or abssent; it does
  not use \code{fill} or \code{fun} in this determination. See \code{details}
  for more info about how levels are selected.
}
\details{
\code{get_best_levels} determines the levels of \code{groups} that
  are likely to be good predictors by fitting a linear or logistic regression
  of \code{outcome} on all of the levels of \code{groups}. The unit of
  observation for this model is all values of \code{id} that have the level.
  Only presence or absence of the level is considered. Levels are ranked by
  their test-statistics from this model and an attempt is made to return an
  equal number of the strongest positive and negative predictors.
}
\examples{
set.seed(45796)
df <- tibble::tibble(
  patient = paste0("Z", sample(1e6, 5)),
  age = sample(20:80, 5),
  died = sample(c("N", "Y"), 5, replace = TRUE, prob = c(2, 1))
)
meds <- tibble::tibble(
  patient = sample(df$patient, 10, replace = TRUE),
  drug = sample(c("Quinapril", "Vancomycin", "Ibuprofen",
                  "Paclitaxel", "Epinephrine", "Dexamethasone"),
                10, replace = TRUE),
  dose = sample(c(100, 250), 10, replace = TRUE)
)
get_best_levels(d = df,
                longsheet = meds,
                id = patient,
                groups = drug,
                outcome = died,
                n_levels = 3)
new_df <- add_best_levels(d = df,
                          longsheet = meds,
                          id = patient,
                          groups = drug,
                          outcome = died,
                          n_levels = 3,
                          fill = dose,
                          fun = sum,
                          missing_fill = 0)
new_df
# The names of drugs to make columns from are stored in an attribute of new_df
# so that the same columns can be used in deployment
attr(new_df, "drug_levels")
test_df <- tibble::tibble(
  patient = "Z12345",
  age = 30
)
test_meds <- tibble::tibble(
  patient = rep("Z12345", 2),
  drug = rep("Vancomycin", 2),
  dose = c(100, 250)
)
add_best_levels(d = test_df,
                longsheet = test_meds,
                id = patient,
                groups = drug,
                levels = attr(new_df, "drug_levels"),
                fill = dose,
                missing_fill = 0)
}
\seealso{
\code{\link{pivot}}
}
